<link rel="import" href="../bower_components/polymer/polymer.html">
<script src="../bower_components/augment/augment.js"></script>

<script>var module = {};</script>
<script src="../bower_components/parser-generator/parser-generator.js"></script>
<script>var Parser = module.exports; module = undefined;</script>

<script src="parse-grammar.js"></script>

<dom-module id="parse-service">

    <script>
        Polymer({
            is: 'parse-service',


            _tokens: function(o) {
                var o = Parser.Operators;
                var g = new Mt940Grammar(o, Mt940LogLevel.None);

                // basic tokens
                g.$token("lbrace", "{");
                g.$token("rbrace", "}");
                g.$token("colon", ":");
                g.$token("dash", "-");
                g.$token("number", /[0-9]+/);
                g.$token("alpha", /[A-Z]+/);
                g.$token("alphanum", /[A-Z0-9]+/);
                g.$token("anychar", /[^\n]+/);
                g.$token("float", /[0-9]+,[0-9]+/);
                g.$token("newline", "\n");

                return g;
            },

            _grammar: function(o) {
                var g = this._tokens(o);

                g.$rule("tag", o.each(g.alphanum, g.colon));
                g.$rule("fieldname", o.each(g.newline, g.colon, g.tag));
                g.$rule("endSuccessor", o.any(g.rbrace, g.newline));
                // NOTE, that there is data where a dash starts a data line, so we need to be picky about whether it's the end or not
                g.$rule("endContradiction", o.not(g.endSuccessor));
                g.$rule("end", o.each(g.newline, g.dash, o.not(g.endContradiction)));

                g.$rule("headercontent", o.each(g.tag, g.alphanum));
                g.$rule("headerblock", o.between(g.lbrace, g.headercontent, g.rbrace));
                // NOTE, that a header might be empty
                g.$rule("header", o.many(g.headerblock));

                g.$rule("fielddataline", o.each(o.not(g.end), o.not(g.fieldname), o.ignore(o.optional(g.newline)), o.min(1, g.anychar)));
                g.$rule("fielddata", o.many(g.fielddataline));
                g.$rule("field", o.each(g.fieldname, g.fielddata));
                g.$rule("fields", o.many(g.field));
                g.$rule("fieldsInBraces", o.each(g.lbrace, g.tag, g.fields, g.end, g.rbrace));
                // HINT, that I found examples with and without braces
                // NOTE, that fieldsInBraces (more complex) must come before fields (fallback/simple)
                g.$rule("body", o.any(g.fieldsInBraces, g.fields));

                g.$rule("file", o.each(g.header, g.body));

                return g;
            },

            parseTransactions: function(data) {
                console.log("Parsing " + data.length + " bytes ...");

                var normalized = data.replace(/\r\n/g, "\n");
                var parse = this._grammar(Parser.Operators);
                var file = parse.file(normalized);
                if (file[1] != "") {
                    throw new Error("Couldn't be parsed completely, remaining: " + file[1]);
                }
                return file[0];
            }
        });
    </script>

</dom-module>