<link rel="import" href="../bower_components/polymer/polymer.html">
<script src="../bower_components/augment/augment.js"></script>

<script>
    window.Mt940Parser = new Object;
</script>

<link rel="import" href="../src/mt940-parser/parser-generator.html"></script>
<script src="../src/mt940-parser/ast-element.js"></script>
<script src="../src/mt940-parser/grammar.js"></script>

<dom-module id="mt940-parser-service">

    <script>
        Polymer({
            is: 'mt940-parser-service',

            _tokens: function(o) {
                var o = Mt940Parser.ParserGenerator.Operators;
                var g = new Mt940Parser.Grammar(o, Mt940Parser.LogLevel.None);

                // basic tokens
                g.$token("lbrace", "{");
                g.$token("rbrace", "}");
                g.$token("colon", ":");
                g.$token("dash", "-");
                g.$token("number", /[0-9]+/);
                g.$token("alpha", /[A-Z]+/);
                g.$token("alphanum", /[A-Z0-9]+/);
                g.$token("anychar", /[^\n]+/);
                g.$token("float", /[0-9]+,[0-9]+/);
                g.$token("newline", "\n");

                return g;
            },

            _grammar: function(o) {
                var g = this._tokens(o);

                g.$rule("tag", o.each(g.alphanum, g.colon));
                g.$rule("fieldName", o.each(g.newline, g.colon, g.tag));
                g.$rule("endSuccessor", o.any(g.rbrace, g.newline));
                // NOTE, that there is data where a dash starts a data line, so we need to be picky about whether it's the end or not
                g.$rule("endContradiction", o.not(g.endSuccessor));
                g.$rule("end", o.each(g.newline, g.dash, o.not(g.endContradiction)));

                g.$rule("headerContent", o.each(g.tag, g.alphanum));
                g.$rule("headerBlock", o.between(g.lbrace, g.headerContent, g.rbrace));
                // NOTE, that a header might be empty
                g.$rule("header", o.many(g.headerBlock));

                g.$rule("fieldDataLine", o.each(o.not(g.end), o.not(g.fieldName), o.ignore(o.optional(g.newline)), o.min(1, g.anychar)));
                g.$rule("fieldData", o.many(g.fieldDataLine));
                g.$rule("field", o.each(g.fieldName, g.fieldData));
                g.$rule("fields", o.many(g.field));
                g.$rule("fieldsInBraces", o.each(g.lbrace, g.tag, g.fields, g.end, g.rbrace));
                // HINT, that I found examples with and without braces
                // NOTE, that fieldsInBraces (more complex) must come before fields (fallback/simple)
                g.$rule("body", o.any(g.fieldsInBraces, g.fields));

                g.$rule("file", o.each(g.header, g.body));

                return g;
            },

            parseTransactions: function(data) {
                console.log("Parsing " + data.length + " bytes ...");

                var normalized = data.replace(/\r\n/g, "\n");
                var parse = this._grammar(Mt940Parser.ParserGenerator.Operators);
                var file = parse.file(normalized);
                if (file[1] != "") {
                    throw new Error("Couldn't be parsed completely, remaining: " + file[1]);
                }
                return file[0];
            }
        });
    </script>

</dom-module>